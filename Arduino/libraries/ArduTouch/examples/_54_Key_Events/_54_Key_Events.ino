//
//  _54_Key_Events.ino
// 
//  This sketch shows how to process ArduTouch keyboard events. It introduces
//  an important call-back method, evHandler(), which is used to process events 
//  generated by the ArduTouch system.
//   
//  In this example we construct a synth which plays a sine wave tone when the 
//  user presses a key on the ArduTouch keyboard. 
//
//  The keyboard tuning in this example is not that of a "normal" keyboard -- 
//  it uses arithmetic tuning (and not musical notes). A musical note keyboard 
//  (using a standard equal tempered scale) is shown in a later example.
// 
//  Target:   ArduTouch board
// 
//  ---------------------------------------------------------------------------
// 
//  Copyright (C) 2016, Cornfield Electronics, Inc.
// 
//  This work is licensed under the Creative Commons Attribution-ShareAlike 3.0 
//  Unported License.
// 
//  To view a copy of this license, visit
//  http://creativecommons.org/licenses/by-sa/3.0/
// 
//  Created by Bill Alessi & Mitch Altman.
// 
//  ---------------------------------------------------------------------------


#include "ArduTouch.h"                       // use the ArduTouch library 

about_program( Key Events, 1.00 )            // specify sketch name & version

class ArithmeticSynth : public Synth
{
   public:

   WaveOsc osc;                              // use a wave table oscillator 

   double  baseHz;                           // frequency to play when touch low C key
   double  tuneHz;                           // freq interval between keys
   boolean keyDown;                          // this is true when a key is pressed


   // this initialize() method initializes our oscillator to use a sine wave wavetable,
   // and sets up our state variables.

   void initialize() 
   {  
      osc.reset();                           // initialize oscillator state            
      osc.setTable( wavetable(Sine) );       // use Sine table from library

      baseHz  = 200.0;                       // play 200.0 Hz when touching low C key
      tuneHz  = 25.0;                        // 25.0 Hz arithmetic tuning
      keyDown = false;                       // begin with no key pressed
   }


   //  evHandler() is called by the system whenever an event occurs on the 
   //  ArduTouch board, such as pressing or releasing a key, adjusting a pot
   //  or pressing a button. The system passes information about the event
   //  in an obEvent ("onboard event") struct. The type of the event can be
   //  determined by calling the obEvent's type() method.
   //
   //  In this example we are only interested in 2 types of events: KEY_DOWN 
   //  and KEY_UP.
   //
   //  In the case of a KEY_DOWN event we call the obEvent's getKey() method,
   //  which returns a key struct. This key struct contains information about 
   //  the key pressed, including its position relative to low "C" (low C has 
   //  a position of 0).
   

   boolean evHandler( obEvent e )            // event handler
   {
      switch ( e.type() )
      {
         case KEY_DOWN:                      // a key has been pressed
         {
            keyDown = true;                  // update keyDown status

            // set oscillator frequency according to the key's position 
            // in the octave (an arithmetic scale is used)

            key  k = e.getKey();             // get key info from event
            byte p = k.position();           // get key's position in octave
            double t = baseHz + (p*tuneHz);  // calculate tuning for key
            osc.setFreq( t );                // set oscillator frequency

            return true;                     // KEY_DOWN event was handled
         }

         case KEY_UP:                        // key has been released

            keyDown = false;                 // update keyDown status
            return true;                     // KEY_UP event was handled

         default:       

            return false;                    // ignore all other events
      }
   }


   // output() generates a tone only while a key is being pressed
   // (this is actually somewhat crude, compared with examples coming up,
   // which show ways of handling events that create cleaner sound.)

   void output( char *buf )                  // output 1 buffer of audio
   {
      if ( keyDown )                         // if a key is currently down
         osc.output( buf );                  // pass buffer to oscillator to make the sound
      else                                   // else no key is down 
      {                                      // so clear the buffer to make no sound:
         byte icnt = audioBufSz;             // icnt = # bytes in buffer
         while ( icnt-- )                    // for each byte in buffer
            *buf++ = 0;                      // clear byte
      }
   }


} myArithmeticKeyboardSynth;

//  --------------------------------------------------------------------------
//
//                   An Important Note about Keyboard Events
//
//  The Ardutouch system treats the keyboard as a mono-touch device: if 
//  multiple keys are pressed at once, only the 1st key generates a KEY_DOWN 
//  event. When that key is released, a KEY_UP event is generated, then 
//  the keyboard is re-scanned, and a KEY_DOWN event will be generated for 
//  the lowest key still held (if any).
//
//  --------------------------------------------------------------------------      

void setup()
{
   ardutouch_setup( &myArithmeticKeyboardSynth ); // initialize ArduTouch resources
}


void loop()
{
   ardutouch_loop();                         // perform ongoing ArduTouch tasks  
}                                             

//  --------------------------------------------------------------------------
//
//  If you compile and upload this sketch to the ArduTouch you should hear a 
//  sine wave tone when a key is pressed. The tone's frequency will increase
//  by 25 Hz per key, from left to right. Low C will play a 200 Hz tone.
//
//  This example does not create a keyboard with tuning that you are probably
//  expecting.  Western keyboards use logarithmic tuning (not arithmetic tuning).
//
//  --------------------------------------------------------------------------      



